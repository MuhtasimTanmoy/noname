<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>noname</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="././mdbook-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Language</li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">2.</strong> Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Compiler Internals</li><li class="chapter-item expanded "><a href="compilation.html"><strong aria-hidden="true">3.</strong> Compilation</a></li><li class="chapter-item expanded "><a href="grammar.html"><strong aria-hidden="true">4.</strong> Grammar</a></li><li class="chapter-item expanded "><a href="spans.html"><strong aria-hidden="true">5.</strong> Spans</a></li><li class="chapter-item expanded "><a href="type-checker.html"><strong aria-hidden="true">6.</strong> Type Checker</a></li><li class="chapter-item expanded "><a href="asm.html"><strong aria-hidden="true">7.</strong> Noname ASM</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded affix "><li class="part-title">Circuit Generation</li><li class="chapter-item expanded "><a href="cellvar.html"><strong aria-hidden="true">9.</strong> CellVars</a></li><li class="chapter-item expanded "><a href="var.html"><strong aria-hidden="true">10.</strong> Vars</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">11.</strong> Constants</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">12.</strong> Functions</a></li><li class="chapter-item expanded "><a href="scope.html"><strong aria-hidden="true">13.</strong> Scope</a></li><li class="chapter-item expanded affix "><li class="part-title">Proof Creation</li><li class="chapter-item expanded "><a href="public-outputs.html"><strong aria-hidden="true">14.</strong> Public Outputs</a></li><li class="chapter-item expanded "><a href="witness-generation.html"><strong aria-hidden="true">15.</strong> Witness Generation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">noname</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://www.github.com/mimoo/noname" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="noname"><a class="header" href="#noname">NoName</a></h1>
<p>This is the book on NoName, a high-level language to write circuits using the <a href="">kimchi</a> zero-knowledge proof system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Noname is a language that closely resembles Rust.</p>
<p>For example, in the following program you can see a <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: Field) {
    let x = private_input + public_input;
    assert_eq(x, 2);
}
</code></pre></pre>
<p>The only differences with Rust are:</p>
<ul>
<li>The <code>pub</code> keyword is used to mark <em>public</em> inputs. By default all arguments are private.</li>
<li><code>assert_eq</code> is not a macro, there are no macros in noname.</li>
<li>a <code>Field</code> type is used as main types everywhere. It is defined in <code>field.rs</code> to be the pasta Fp field (the base field of the Pallas curve). If these words mean nothing to you, just see <code>Field</code> as a large number. Ideally programs should be written without this type, but for now custom types do not exist.</li>
</ul>
<p>To run such a file, and assuming you have <a href="https://rustup.rs/">Rust</a> installed, you can type in the terminal:</p>
<pre><code>$ cargo run -- --path path/to/file.no --private-inputs '{&quot;private_input&quot;: [&quot;1&quot;]}' --public-inputs '{&quot;public_input&quot;: [&quot;1&quot;]}'
</code></pre>
<p>As you can see, inputs are passed with a JSON format, and the values are expected to be encoded in decimal numbers.</p>
<h2 id="builtins-and-use-statements"><a class="header" href="#builtins-and-use-statements">Builtins and use statements</a></h2>
<p>Some builtin functions are available by default:</p>
<ul>
<li><code>assert_eq</code> to check that two field elements are equal</li>
<li><code>assert</code> to check that a condition is true.</li>
</ul>
<p>Like in Rust, you can also import other libraries via the <code>use</code> keyword.
If you do this, you must know that you can only import a library, but not its functions (and types, and constants) directly.</p>
<p>For example, to use the poseidon function from the crypto library (or module), you must import <code>std::crypto</code> and then qualify your use of <code>crypto::poseidon</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::crypto;

fn main(pub public_input: Field, private_input: [Field; 2]) {
    let digest = crypto::poseidon(private_input);
    assert_eq(digest[0], public_input);
}
</code></pre></pre>
<p>Note that currently, only built-in libraries (written in Rust) are working. 
In the future we’d like for other libraries to be written in the noname language.</p>
<h2 id="field"><a class="header" href="#field">Field</a></h2>
<p>The <code>Field</code> type is the primitive type upon which all other types are built. 
It is good to know about it as it is used in many places, and is error prone: it does not match the size of commonly-found types like <code>u32</code> and <code>u64</code> and can have unexpected behaviors as it can overflow or underflow  without emitting an error.</p>
<p>Ideally, you should never use the <code>Field</code> type, but currently the library is quite limited and the ideal world is far away.</p>
<p>Note that you can define <code>Field</code> elements directly in the code by writing a decimal number directly. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
assert(y, 4);
<span class="boring">}
</span></code></pre></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>While there are no dynamic arrays (or vectors), you can use fixed-size arrays like in Rust.</p>
<p>For the moment, I believe that arrays can only be declared in a function argument as the following declaration hasn’t been implemented yet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [1, 2, y];
<span class="boring">}
</span></code></pre></pre>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>Booleans are similar to Rust’s boolean. They are currently the only built-in type besides <code>Field</code> and arrays.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = true;
let y = false;
assert(!(x &amp; y));
<span class="boring">}
</span></code></pre></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>Variables are by default not mutable. To make a variable mutable, you must use the <code>mut</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 1;
x = 2; // GOOD

let y = 1;
y = x + y; // BAD
<span class="boring">}
</span></code></pre></pre>
<h2 id="custom-types"><a class="header" href="#custom-types">Custom types</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Thing {
    x: Field,
    y: Field,
}

fn main(pub x: Field, pub y: Field) {
    let thing = Thing {
        x: 1,
        y: 2,
    };
    
    assert_eq(thing.x, x);
    assert_eq(thing.y, y);
}
</code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops">For loops</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: [Field; 3]) {
    let mut sum = 0;

    for i in 0..3 {
        sum = sum + private_input[i];
    }

    assert_eq(sum, public_input);
}
</code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<pre><pre class="playground"><code class="language-rust">const PLAYER_ONE = 1;
const PLAYER_TWO = 2;

fn main(pub player: Field) -&gt; Field {
    assert_eq(PLAYER_ONE, player);
    let next_player = player + 1;
    assert_eq(PLAYER_TWO, next_player);
    return next_player;
}
</code></pre></pre>
<h2 id="if-else-statements"><a class="header" href="#if-else-statements">If Else statements</a></h2>
<p>TODO</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>TODO</p>
<h2 id="early-returns"><a class="header" href="#early-returns">Early returns</a></h2>
<p>TODO</p>
<h2 id="hints"><a class="header" href="#hints">Hints</a></h2>
<p>TODO</p>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>We forbid variable shadowing as much as we can.</p>
<p>For example, this should not work:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let x = 3; // this won't compile

let y = 4;
for i in 0..4 {
    let y = i; // this won't compile either
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation"><a class="header" href="#compilation">Compilation</a></h1>
<p>The compilation of noname programs goes through the following flow:</p>
<ol>
<li><strong>Lexer</strong>. A lexer (<code>lexer.rs</code>) is used to parse the source code into a list of tokens. This is pretty primitive, but will detect some minor syntax issues.</li>
<li><strong>Parser</strong>. A parser (<code>parser.rs</code>) is used to parse meaning from the code. It will convert the tokens output by the lexer into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a> using strong types like <a href=""><code>Statement</code></a> and <a href=""><code>Expression</code></a> (TODO: link to rust doc). It will also error if some code does not make sense according to the grammar (see the <a href="grammar.html">Grammar chapter</a>).</li>
<li><strong>Type checking</strong>. A type checker (<code>type_checker.rs</code>) takes the AST produced by the parser and does import resolution and type checking: 
<ul>
<li><strong>Built-in functions</strong>. Functions like <code>assert_eq</code> are injected into the environment.</li>
<li><strong>Custom imports</strong>. Modules imported via the <code>use</code> keyword are resolved and added to the environment. For now, these can only be built-in functions, and noname functions or libraries are not supported (of course it is essential to support them in the future).</li>
<li><strong>Type checking</strong>. The type checker verifies that the types of each variables and expressions in the AST make sense. It is a very simple type checker that can do some simple type inference. Temporary type information (type of an expression) is not stored, and is thrown away as soon as the type checker can afford it. a TAST for typed AST is returned, but it mostly contains resolved imports and most type information has been thrown away.</li>
</ul>
</li>
<li><strong>Gate construction</strong>. The TAST produced by the type checker is passed to the circuit writer (<code>circuit_writer.rs</code>) which goes through it one more time and converts it into:
<ul>
<li><strong>compiled circuit</strong>: a series of gates and wires</li>
<li><strong>prover instructions</strong>: instructions on how to run the function for the witness generation (used by the prover)</li>
</ul>
</li>
</ol>
<p>A simple ASM language is also used, and the circuit can be encoded in this language. See the <a href="asm.html">ASM chapter</a>.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>A note on topology:</p>
<ul>
<li><strong>functions</strong>: noname functions each contain their scope and can be interacted with their interface (arguments and return value)</li>
<li><strong>module/program</strong>: a noname module is a single file (this is a nice current limitation of noname) containing functions, constants, and structures. </li>
<li><strong>library</strong>: a noname library is a module/program without a <code>main()</code> function, as well as dependencies (other libraries)</li>
<li><strong>executable</strong>: a noname executable is like a library, except that its module/program has a <code>main()</code> function.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grammar"><a class="header" href="#grammar">Grammar</a></h1>
<p>The syntax of the noname language is described through its grammar.</p>
<p>We use a notation similar to the Backus-Naur Form (BNF)
to describe the grammar:</p>
<pre>
land := city "|"
 ^        ^   ^
 |        |  terminal: a token
 |        |
 |      another non-terminal
 |
 non-terminal: definition of a piece of code
city := [ sign ] "," { house }
        ^            ^
        optional     |
                    0r or more houses
sign := /a-zA-Z_/
        ^
        regex-style definition
</pre>
<p>There are some comments in the parser code (<code>parser.rs</code>) that attempt to define this grammar.</p>
<p>Essentially, it is made to look like Rust, but with some differences of philosophies:</p>
<ul>
<li>expressions cannot be statements, unless they return no value (act using side effects).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spans"><a class="header" href="#spans">Spans</a></h1>
<p>To be able to efficiently track errors, we have a span type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Span(pub usize, pub usize);
<span class="boring">}
</span></code></pre></pre>
<p>which represents a location in the original source code:</p>
<ul>
<li>the first number is the offset in the source code file</li>
<li>the second numebr if the length of the span (e.g. 1 character)</li>
</ul>
<p>We start tracking spans in the lexer, and then pass them around to the parser, and then to the compiler. Even gates and wirings have spans associated with them so that we can easily debug those.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-checker"><a class="header" href="#type-checker">Type Checker</a></h1>
<p>Noname uses a simple type checker to ensure that all types are consistent in the program.</p>
<p>For example, in code like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = y + z;
<span class="boring">}
</span></code></pre></pre>
<p>the type checker will ensure that <code>y</code> and <code>z</code> are both field elements (because the operation <code>+</code> is used).</p>
<p>And in code like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq(a, b);
<span class="boring">}
</span></code></pre></pre>
<p>the type checker will ensure that <code>a</code> and <code>b</code> are of the same types, since they are being compared.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h2>
<p>The type checker can do some simple type inference. For example, in the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = y + z;
<span class="boring">}
</span></code></pre></pre>
<p>the type of <code>x</code> is inferred to be the same as the type of <code>y</code> and <code>z</code>.</p>
<p>Inference is willingly kept naive, as more type inference would lead to less readable code.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The type checker must be aware of scopes, as it keeps track of the type of variables and functions that are local to each scope.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
for i in 0..2 {
    let y = x + 1; // x exists inside of this for loop
}
let z = 1 + y; // BAD: y doesn't exist outside of the for loop
<span class="boring">}
</span></code></pre></pre>
<p>To do this, each function is passed an <a href="">Environment</a> which contains a list of all variables along with their type information.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Environment {
    /// created by the type checker, gives a type to every external variable
    pub var_types: HashMap&lt;String, TypeInfo&gt;,

    // ...

    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    pub functions: HashMap&lt;String, FuncInScope&gt;,

    /// stores the imported modules
    pub modules: HashMap&lt;String, ImportedModule&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>So that shadowing is disallowed, even in different scopes, there is only one variable that is stored, but the scope is stored in <code>TypeInfo</code> and matched against the current scope to see if the current scope is the same or a direct child.</p>
<p>An environment is unique to a function, as it is important that different functions can use the same variable names.</p>
<p>Some notes:</p>
<ul>
<li>Currently the notion of module is quite shaky. It is used mostly for <code>crypto::poseidon</code> at the moment.</li>
<li><code>functions</code> is mostly used for builtins like <code>assert_eq</code></li>
<li><code>modules</code> is mostly used for the functions in <code>std::crypto</code>, which only contains <code>crypto::poseidon</code> atm.</li>
</ul>
<p>more:</p>
<ul>
<li>I think Environment mixes things</li>
<li>we should be able to create a new Environment whenever we parse a new function, so the functions/modules should be part of another (AvailableToAllScopes)</li>
<li>variables is something that has nothing to do with the “Type” Environment and should be moved elsewhere no? GateCreationEnv?</li>
<li>there needs to be a namespace in the typeinfo</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noname-asm"><a class="header" href="#noname-asm">noname ASM</a></h1>
<p>The circuit that noname compiles to can be serialized as a simple ASM language. For example the following noname program:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: Field) {
    let x = private_input + public_input;
    assert_eq(x, 2);
}
</code></pre></pre>
<p>will be compiled to the following noname asm:</p>
<pre><code>@ noname.0.4.0

DoubleGeneric&lt;1&gt;
DoubleGeneric&lt;1,1,-1&gt;
DoubleGeneric&lt;1,0,0,0,-2&gt;
DoubleGeneric&lt;1,-1&gt;
(0,0) -&gt; (1,1)
(1,2) -&gt; (3,1)
(2,0) -&gt; (3,0)
</code></pre>
<p>which includes:</p>
<ul>
<li><strong>the version</strong> of noname used to compile this circuit. This is important as the prover needs to know what version of noname to use to prove executions of this circuit.</li>
<li><strong>a list of gates</strong> and how they are tweaked (the values in the brackets).</li>
<li><strong>a list of wires</strong> which is canonically ordered so that every compilation gives the same resulting noname asm.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>User can define custom structs like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thing {
    x: Field,
    y: Field,
}
<span class="boring">}
</span></code></pre></pre>
<p>and can declare and access such structs like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = Thing { x: 1, y: 2 };
let z = thing.x + thing.y;
<span class="boring">}
</span></code></pre></pre>
<p>Internally, a struct is represented within the <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cellvar"><a class="header" href="#cellvar">CellVar</a></h1>
<p>A <a href="https://mimoo.github.io/noname/rustdoc/var/struct.CellVar.html"><code>CellVar</code></a> type is a type that represents an internal variable. Importantly, it is named after the fact that it relates to a specific cell, or even multiple cells if they will have the same value (using some wiring), in the execution trace.</p>
<p>A <code>CellVar</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CellVar {
    index: usize,
    span: Span,
}
<span class="boring">}
</span></code></pre></pre>
<p>It is tracked using a <code>usize</code>, which is just a counter that the compiler increments every time a new <code>CellVar</code> is created.</p>
<p>A <code>CellVar</code> is created via the <code>new_internal_var</code> function which does two things: increments the variable counter, and stores some information on how to compute it (which will be useful during witness generation)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new_internal_var(&amp;mut self, val: Value, span: Span) -&gt; CellVar {
    // create new var
    let var = CellVar::new(self.next_variable, span);
    self.next_variable += 1;

    // store it in the compiler
    self.witness_vars.insert(var, val);

    var
}
<span class="boring">}
</span></code></pre></pre>
<p>a <code>Value</code> tells us how to compute the <code>CellVar</code> during witness generation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Value {
    /// Either it's a hint and can be computed from the outside.
    Hint(Box&lt;dyn Fn(&amp;Compiler, &amp;mut WitnessEnv) -&gt; Result&lt;Field&gt;&gt;),

    /// Or it's a constant (for example, I wrote `2` in the code).
    Constant(Field),

    /// Or it's a linear combination of internal circuit variables (+ a constant).
    LinearCombination(Vec&lt;(Field, CellVar)&gt;, Field),

    /// A public or private input to the function
    /// There's an index associated to a variable name, as the variable could be composed of several field elements.
    External(String, usize),

    /// A public output.
    /// This is tracked separately as public inputs as it needs to be computed later.
    PublicOutput(Option&lt;CellVar&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Note: a <code>CellVar</code> is potentially not directly added to the rows of the execution trace. 
For example, a private input is converted directly to a (number of) <code>CellVar</code>(s), 
but only added to the rows when it appears in a constraint for the first time.</p>
<p>As the final step of the compilation, we double check that all <code>CellVar</code>s have appeared in the rows of the execution trace at some point. If they haven’t, it can mean two things:</p>
<ul>
<li>A private or public input was never used in the circuit. In this case we return an error to the user.</li>
<li>There is a bug in the compiler. In this case we panic.</li>
</ul>
<p>TODO: explain the LinearCombination. I think we only need an <code>Add((Field, Var), (Field, Var), Field)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vars"><a class="header" href="#vars">Vars</a></h1>
<p>We already have <a href="./cellvar.html"><code>CellVar</code></a>s, why have <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a>s? 
The distinction is a matter of abstraction: </p>
<ul>
<li><code>CellVar</code>s are low-level: they track actual cells of the execution trace. When a single <code>CellVar</code> is assigned to multiple cells the wiring must make sure the cells are wired (so that they can only have the same value).</li>
<li><code>Var</code>s are a higher-level concept: they track variables that are created in the noname language either directly (e.g. <code>let x = 3</code>) or indirectly (e.g. in <code>x + (y + z)</code> the term <code>y + z</code> is stored under an anonymous <code>Var</code>)</li>
</ul>
<p>While a <code>CellVar</code> represents a single field element, a <code>Var</code> can potentially represent several field elements (and as such several cells in the execution trace). 
Here are some examples of <code>Var</code>s:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a constant
let x = 5;

// a field element that will be computed at runtime
let y = private_input + 1;

// a builtin type, like an array, or a bool
let z = [y, x, 6];

// or a custom type
let s = Thing { x, y };
<span class="boring">}
</span></code></pre></pre>
<p>Internally, a <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a> is represented as such:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A constant value created in a noname program
pub struct Constant {
    /// The actual value.
    pub value: Field,

    /// The span that created the constant.
    pub span: Span,
}

/// Represents a cell in the execution trace.
pub enum ConstOrCell {
    /// A constant value.
    Const(Constant),

    /// A cell in the execution trace.
    Cell(CellVar),
}

/// A variable in a program can have different shapes.
pub enum VarKind {
    /// We pack [Const] and [CellVar] in the same enum because we often branch on these.
    ConstOrCell(ConstOrCell),

    /// A struct is represented as a mapping between field names and other [VarKind]s.
    Struct(HashMap&lt;String, VarKind&gt;),

    /// An array or a tuple is represetend as a list of other [VarKind]s.
    ArrayOrTuple(Vec&lt;VarKind&gt;),
}

/// Represents a variable in the noname language, or an anonymous variable during computation of expressions.
pub struct Var {
    /// The type of variable.
    pub kind: VarKind,

    /// The span that created the variable.
    pub span: Span,
}
<span class="boring">}
</span></code></pre></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="var.html#admonition-note"></a></p>
</div>
<div>
<p>Note: see the <a href="./constants.html">Constant chapter</a> to see why constants are treated differently.</p>
</div>
</div>
<h2 id="anonymous-variable"><a class="header" href="#anonymous-variable">Anonymous variable</a></h2>
<p>Here’s a short note on anonymous variable.</p>
<p>When circuit writer parses the <a href="./compilation.html">ast</a>, it will convert each expression into a <code>Var</code> (unless the expression does not compute to an actual value).</p>
<p>In our example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = t + (z + y);
<span class="boring">}
</span></code></pre></pre>
<p>the <code>z + y</code> is parsed as an expression (a binary operation involving <code>z</code> and <code>y</code>) and stored under a var <code>var1</code>. 
Then <code>t + ...</code> is also parsed as another binary operation expression and stored under another var <code>var2</code>.
Finally the <code>let x = ...</code> is parsed as an assignment statement, and <code>x</code> is stored as a local variable associated to the right handside var <code>var2</code>.</p>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="var.html#admonition-note-1"></a></p>
</div>
<div>
<p>See the <a href="./scope.html">Scope chapter</a> for more information on local variables.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-1"><a class="header" href="#constants-1">Constants</a></h1>
<p>Developers write constants in their code all the time. For example, the following code has two constants <code>2</code> and <code>4</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2 + y;
assert_eq(x, 4);
<span class="boring">}
</span></code></pre></pre>
<p>It is important that constants are tracked differently than <code>CellVar</code>s for several reasons:</p>
<ul>
<li>It is sometimes useless to constrain them directly. For example, in <code>let x = 3 + 7;</code> you can see that we should not constrain <code>3</code> and <code>7</code> separately, but rather the result <code>10</code>.</li>
<li>It is sometimes useless to constrain them at all. For example, boolean constants are never constrained because you never need to.</li>
<li>They can be cached to avoid creating several constraints for the same constant.</li>
</ul>
<p>Currently a constant appears in the circuit only when <code>CircuitWriter::add_constant</code> is called.
It uses the generic gate to constrain the value, and is not cached (so calling it several times with the same constant will create multiple constraints):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_constant(&amp;mut self, value: Field, span: Span) -&gt; CellVar {
    let var = self.new_internal_var(Value::Constant(value), span);

    let zero = Field::zero();
    self.add_gate(
        GateKind::DoubleGeneric,
        vec![Some(var)],
        vec![Field::one(), zero, zero, zero, value.neg()],
        span,
    );

    var
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the <code>Value</code> keep track of the constant as well.</p>
<p>Warning: gadgets must all handle constants gracefuly.
That is, they must constrain constants themselves (by calling <code>CircuitWriter::add_constant</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-environment"><a class="header" href="#global-environment">Global environment</a></h1>
<p>In this chapter we will talk about functions.</p>
<h2 id="local-functions"><a class="header" href="#local-functions">Local functions</a></h2>
<p>Third-party libraries can have function names that collide with your own function names. 
Due to this, they are tracked in a different data structure that we will see later.</p>
<p>Local functions include:</p>
<ul>
<li><strong>automatically imported built-ins</strong>. Think functions like <code>assert</code> and <code>assert_eq</code>. See <a href="./basics.html#Builtins-and-use-statements">here</a> for a full list.</li>
<li><strong>main</strong>, this is the main function that your program runs. Of course if you’re writing a library this function is not present.</li>
<li><strong>normal functions</strong>, these are functions that you define in your program. They can be recursive.</li>
<li><strong>methods</strong>, these are functions that are defined on a type. They can be recursive as well.</li>
</ul>
<p>Built-ins are different from all other functions listed because they are not written in noname, but written in Rust within the compiler. </p>
<p>For this reason we track functions according to this enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FnKind {
    /// signature of the function
    BuiltIn(FnHandle),

    /// Any function declared in the noname program (including main)
    LocalFn(AST)

    /// path, and signature of the function
    Library(Vec&lt;String&gt;),
}

/// An actual handle to the internal function to call to resolve a built-in function call.
pub type FnHandle = fn(&amp;mut CircuitWriter, &amp;[Var], Span) -&gt; Result&lt;Option&lt;Var&gt;&gt;;

pub struct FnInfo {
    pub name: Ident,
    pub sig: FnSig,
    pub kind: FnKind,
    pub span: Span,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the signature of a <code>FnHandle</code> is designed to:</p>
<ul>
<li><code>&amp;mut CircuitWriter</code>: take a mutable reference to the circuit writer, this is because built-ins need to be able to register new variables and add gates to the circuit</li>
<li><code>&amp;[Var]</code>: take an unbounded list of variables, this is because built-ins can take any number of arguments, and different built-ins might take different types of arguments</li>
<li><code>Span</code>: take a span to return user-friendly errors</li>
<li><code>-&gt; Result&lt;Option&lt;Var&gt;&gt;</code>: return a <code>Result</code> with an <code>Option</code> of a <code>Var</code>. This is because built-ins can return a variable, or they can return nothing. If they return nothing, then the <code>Option</code> will be <code>None</code>. If they return a variable, then the <code>Option</code> will be <code>Some(Var)</code>.</li>
</ul>
<p>We track all of these functions in the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GlobalEnv {
    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    functions: HashMap&lt;String, FnInfo&gt;,

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="handling-builtins"><a class="header" href="#handling-builtins">Handling builtins</a></h2>
<p>Builtins are handled in a special way. They are not written in noname, but in Rust.</p>
<h2 id="handling-local-functions"><a class="header" href="#handling-local-functions">Handling local functions</a></h2>
<p>The parser:</p>
<ul>
<li>saves the AST of each function it encounters. Specifically, the function’s AST is stored under the <code>GlobalEnv</code> (TODO: where exactly?). This is necessary as the circuit writer will have to switch to a function’s AST when a function is called (and then return to its own AST).</li>
</ul>
<p>The first step of the type checker resolves imports by doing the following:</p>
<ul>
<li>store all built-ins in the <code>functions</code> map of the <code>GlobalEnv</code></li>
<li>resolve all imports (e.g. <code>use std::crypto</code>)</li>
<li>type check each function individually, and save their signature in the <code>GlobalEnv</code> using the <code>FnSig</code> type</li>
<li>type check function calls with the signatures they just saved </li>
</ul>
<p>(TODO: this means that function declaration must be ordered. I think it is a GOOD thing)</p>
<p>When a function is called, we do the following:</p>
<ul>
<li>if the function is qualified (e.g. <code>crypto::poseidon</code>), then lookup imported modules (see next section)</li>
<li>otherwise, check if the function exist in the <code>GlobalEnv</code>, if it doesn’t then return an error</li>
<li>if the function exist, then create a new <code>FnEnv</code> and register the arguments as local variables there</li>
<li>switch to the function’s AST and pass the new <code>FnEnv</code> as argument</li>
<li>TODO: how to handle the return value? it should be saved in the <code>FnEnv</code></li>
</ul>
<h2 id="third-party-libraries"><a class="header" href="#third-party-libraries">Third-party libraries</a></h2>
<p>TODO: write this part</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This seems to be used by both the type checker and the AST
// TODO: right now there's only one scope, but if we want to deal with multiple scopes then we'll need to make sure child scopes have access to parent scope, shadowing, etc.
#[derive(Default, Debug)]
pub struct GlobalEnv {
    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    pub functions: HashMap&lt;String, FuncInScope&gt;,

    /// stores the imported modules
    pub modules: HashMap&lt;String, ImportedModule&gt;,

    /// the arguments expected by main
    pub main_args: (HashMap&lt;String, FuncArg&gt;, Span),
}

pub type FnHandle = fn(&amp;mut CircuitWriter, &amp;[Var], Span) -&gt; Result&lt;Option&lt;Var&gt;&gt;;

pub enum FuncInScope {
    /// signature of the function
    BuiltIn(FnSig, FnHandle),

    /// path, and signature of the function
    Library(Vec&lt;String&gt;, FnSig),
}
<span class="boring">}
</span></code></pre></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="functions.html#admonition-note"></a></p>
</div>
<div>
<p>Not all modules are third-party libraries, some are also built-ins (e.g. <code>std::crypto</code>).</p>
</div>
</div>
<p>As part of resolving imports, the type checker looks at third-party libraries differently…</p>
<p>TODO: implement this</p>
<p>TODO: how to handle diamond dependency graph or cycles? We must form a dependency graph first, and resolve dependency according to this graph</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-1"><a class="header" href="#scope-1">Scope</a></h1>
<p>Like most languages, noname has a notion of scope within a function.
Unlike a lot of languages noname forbids shadowing at all scope level.
This means that eventhough different functions can use local variable with colliding names, the local variable of one function must all have different names.</p>
<p>For example, the following code does not compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let x = 3; // this won't compile

let y = 4;
for i in 0..4 {
    let y = i; // this won't compile either
}
<span class="boring">}
</span></code></pre></pre>
<p>Scopes are only used for:</p>
<ul>
<li>for loops</li>
<li>in the future: if/else statements</li>
</ul>
<h2 id="scope-mechanisms"><a class="header" href="#scope-mechanisms">Scope mechanisms</a></h2>
<p>Both the type checker and the circuit writer need to keep track of local variable.
For the type checker (<code>type_checker.rs</code>), a <code>TypeEnv</code> structure keeps track of the association between all local variables names and their type information.
For the circuit writer (<code>circuit_writer.rs</code>), a <code>FnEnv</code> structure keeps track of the association between all local variable names and their circuit variable.</p>
<p>Both structure also keep track of how nested the current block is (the top level starting at level 0).
For this reason, it is important to remember to increase the current scope when entering a new block (for loop, if statement, etc.) and to decrease it when exiting the block.
In addition, all variables from a scope must be disabled (but not deleted, in order to detect shadowing) when exiting that scope.</p>
<p>For example, the type checker’s <code>TypeEnv</code> structure implements the following logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TypeEnv {
    // ...


    /// Enters a scoped block.
    pub fn nest(&amp;mut self) {
        self.current_scope += 1;
    }

    /// Exits a scoped block.
    pub fn pop(&amp;mut self) {
        self.current_scope.checked_sub(1).expect(&quot;scope bug&quot;);

        // disable variables as we exit the scope
        for (name, (scope, type_info)) in self.vars.iter_mut() {
            if *scope &gt; self.current_scope {
                type_info.disabled = true;
            }
        }
    }

    /// Returns true if a scope is a prefix of our scope.
    pub fn is_in_scope(&amp;self, prefix_scope: usize) -&gt; bool {
        self.current_scope &gt;= prefix_scope
    }

    /// Stores type information about a local variable.
    /// Note that we forbid shadowing at all scopes.
    pub fn store_type(&amp;mut self, ident: String, type_info: TypeInfo) -&gt; Result&lt;()&gt; {
        match self
            .vars
            .insert(ident.clone(), (self.current_scope, type_info.clone()))
        {
            Some(_) =&gt; Err(Error {
                kind: ErrorKind::DuplicateDefinition(ident),
                span: type_info.span,
            }),
            None =&gt; Ok(()),
        }
    }

    /// Retrieves type information on a variable, given a name.
    /// If the variable is not in scope, return false.
    pub fn get_type_info(&amp;self, ident: &amp;str) -&gt; Option&lt;TypeInfo&gt; {
        if let Some((scope, type_info)) = self.vars.get(ident) {
            if self.is_in_scope(*scope) &amp;&amp; !type_info.disabled {
                Some(type_info.clone())
            } else {
                None
            }
        } else {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-outputs"><a class="header" href="#public-outputs">Public Outputs</a></h1>
<p>Public outputs are usually part of the public inputs in Plonk.</p>
<p>In noname, public ouputs are treated differently than the public inputs for one reason: unlike (real) public inputs they cannot be computed directly during witness generation (proving).</p>
<p>This is because public inputs are listed first in the circuit. During witness generation, we go through each rows and evaluate the values of the cells to construct the execution trace. 
When we reach the public output part of the public input, we do not yet have enough information to construct the values.
Thus, we ignore them, and fill them later on.</p>
<p>During the compilation, we create <code>CellVars</code> to keep track of the public output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Compiler {
    // ...

    /// If a public output is set, this will be used to store its [CircuitVar] (cvar).
    /// The public output generation works as follows:
    /// 1. This cvar is created and inserted in the circuit (gates) during compilation of the public input
    ///    (as the public output is the end of the public input)
    /// 2. When the `return` statement of the circuit is parsed,
    ///    it will set this `public_output` variable again to the correct vars.
    /// 3. During witness generation, the public output computation
    ///    is delayed until the very end.
    pub public_output: Option&lt;CellVars&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>During witness generation (see the <a href="./witness-generation.html">Witness Generation chapter</a>), we indeed defer computation the first time we go through the public output rows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = if let Some(var) = var {
    // if it's a public output, defer it's computation
    if matches!(self.witness_vars[&amp;var], Value::PublicOutput(_)) {
        public_outputs_vars.push((row, *var));
        Field::zero()
    } else {
        self.compute_var(&amp;mut env, *var)?
    }
} else {
    Field::zero()
};
witness_row[col] = val;
<span class="boring">}
</span></code></pre></pre>
<p>and at the end we go back to them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// compute public output at last
let mut public_output = vec![];

for (row, var) in public_outputs_vars {
    let val = self.compute_var(&amp;mut env, var)?;
    witness[row][0] = val;
    public_output.push(val);
}
<span class="boring">}
</span></code></pre></pre>
<p>and finally we return the public output to the prover so that they can send it to the verifier, as well as the “full public input” which is the concatenation of the public input and the public output (needed to finalized the proof):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// return the public output separately as well
Ok((Witness(witness), full_public_inputs, public_output))
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="witness-generation"><a class="header" href="#witness-generation">Witness Generation</a></h1>
<p>Witness generation is the process of creating the execution trace table during proving. 
The execution trace table is then passed to the <a href="">kimchi</a> proof system which will create the final proof.</p>
<p>The code creates a series of instructions during compilation for the witness generation to follow.
These instructions are stored as two different fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Compiler {
    // ...

    /// This is how you compute the value of each variable, for witness generation.
    pub witness_vars: HashMap&lt;CellVar, Value&gt;,

    // ...

    /// This is used to compute the witness row by row.
    pub rows_of_vars: Vec&lt;Vec&lt;Option&lt;CellVar&gt;&gt;&gt;,

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><code>rows_of_vars</code> can essentially be seen as the execution trace table, containing variables instead of values.</p>
<p>The witness generation goes as follows:</p>
<ol>
<li>Each rows in <code>rows_of_vars</code> is looked at one by one </li>
<li>For each <code>CellVar</code> in the row:
<ol>
<li>If it is set, it is evaluated using the <code>Value</code> stored in <code>witness_vars</code>.</li>
<li>If it set to <code>None</code>, it is simply evaluated as <code>0</code>.</li>
</ol>
</li>
<li>Once the row is created, it is checked for correctness by checking what gate was used in the row. Note that this is only true for the generic gate, as we trust built-in gadgets to produce correct values. For example, <code>assert(x, 2)</code> will be checked because it is using the generic gate, but <code>let y = poseidon(x)</code> won’t be because we trust the poseidon gate to be correct (and if there is a bug there, kimchi will still catch it).</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
